{"version":3,"file":"AgentWakePage-CAM7PhRD.js","sources":["../../../../src/services/subclass-parser.service.ts","../../../../src/services/agent-command.service.ts","../../../../src/pages/AgentWakePage.tsx"],"sourcesContent":["/**\r\n * Subclass Configuration Parser\r\n * Parses natural language subclass/ability/aspect/fragment references\r\n */\r\nimport { SUBCLASS_HASHES, PRISMATIC_ASPECT_MAPPING } from '../constants/item-hashes';\r\n\r\nexport interface SubclassConfig {\r\n    element?: string;\r\n    subclassName?: string;\r\n    subclassHash?: number;\r\n    super?: string;\r\n    grenade?: string | number;\r\n    melee?: string | number;\r\n    classAbility?: string | number;\r\n    jump?: string | number;\r\n    aspects?: string[];\r\n    fragments?: string[];\r\n}\r\n\r\n// Subclass name mappings\r\nconst SUBCLASS_NAMES: Record<string, { titan?: number; hunter?: number; warlock?: number }> = {\r\n    // Void\r\n    'void': { titan: 2842471112, hunter: 2453351420, warlock: 2849050827 },\r\n    'sentinel': { titan: 2842471112 },\r\n    'nightstalker': { hunter: 2453351420 },\r\n    'voidwalker': { warlock: 2849050827 },\r\n\r\n    // Solar\r\n    'solar': { titan: 2550323932, hunter: 2240888816, warlock: 3941205951 },\r\n    'sunbreaker': { titan: 2550323932 },\r\n    'gunslinger': { hunter: 2240888816 },\r\n    'dawnblade': { warlock: 3941205951 },\r\n\r\n    // Arc\r\n    'arc': { titan: 2932390016, hunter: 2328211300, warlock: 3168997075 },\r\n    'striker': { titan: 2932390016 },\r\n    'arcstrider': { hunter: 2328211300 },\r\n    'stormcaller': { warlock: 3168997075 },\r\n\r\n    // Stasis\r\n    'stasis': { titan: 613647804, hunter: 873720784, warlock: 3291545502 },\r\n    'behemoth': { titan: 613647804 },\r\n    'revenant': { hunter: 873720784 },\r\n    'shadebinder': { warlock: 3291545502 },\r\n\r\n    // Strand\r\n    'strand': { titan: 242419885, hunter: 3785442599, warlock: 2849050826 },\r\n    'berserker': { titan: 242419885 },\r\n    'threadrunner': { hunter: 3785442599 },\r\n    'broodweaver': { warlock: 2849050826 },\r\n\r\n    // Prismatic\r\n    'prismatic': { titan: 1616346845, hunter: 4282591831, warlock: 3893112950 },\r\n};\r\n\r\n/**\r\n * Generate ability keywords dynamically from SUBCLASS_HASHES\r\n * This automatically includes all aspects, fragments, grenades, melees from the constants\r\n */\r\ninterface AbilityInfo {\r\n    keywords: string[];\r\n    element: string;\r\n}\r\n\r\nfunction generateAbilityKeywords(): Record<string, AbilityInfo> {\r\n    const keywords: Record<string, AbilityInfo> = {};\r\n\r\n    // Helper to convert constant names to readable format\r\n    const formatName = (key: string): string => {\r\n        return key.toLowerCase().replace(/_/g, ' ');\r\n    };\r\n\r\n    // Extract all abilities from SUBCLASS_HASHES\r\n    const elements = ['VOID', 'SOLAR', 'ARC', 'STASIS', 'STRAND', 'PRISMATIC'] as const;\r\n    const classes = ['TITAN', 'HUNTER', 'WARLOCK'] as const;\r\n\r\n    for (const element of elements) {\r\n        const elementData = SUBCLASS_HASHES[element];\r\n        if (!elementData) continue;\r\n\r\n        for (const guardianClass of classes) {\r\n            const classData = elementData[guardianClass];\r\n            if (!classData) continue;\r\n\r\n            // Extract aspects\r\n            if (classData.ASPECTS) {\r\n                for (const aspectKey of Object.keys(classData.ASPECTS)) {\r\n                    const name = formatName(aspectKey);\r\n                    if (!keywords[name]) {\r\n                        keywords[name] = { keywords: [name], element: element.toLowerCase() };\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Extract grenades\r\n            if (classData.GRENADES) {\r\n                for (const grenadeKey of Object.keys(classData.GRENADES)) {\r\n                    const name = formatName(grenadeKey);\r\n                    const withGrenade = `${name} grenade`;\r\n                    if (!keywords[name]) {\r\n                        keywords[name] = { keywords: [name, withGrenade], element: element.toLowerCase() };\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Extract melees\r\n            if (classData.MELEE) {\r\n                for (const meleeKey of Object.keys(classData.MELEE)) {\r\n                    const name = formatName(meleeKey);\r\n                    if (!keywords[name]) {\r\n                        keywords[name] = { keywords: [name], element: element.toLowerCase() };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Extract fragments (element-level)\r\n        if (elementData.FRAGMENTS) {\r\n            for (const fragmentKey of Object.keys(elementData.FRAGMENTS)) {\r\n                const name = formatName(fragmentKey);\r\n                if (!keywords[name]) {\r\n                    keywords[name] = { keywords: [name], element: element.toLowerCase() };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return keywords;\r\n}\r\n\r\n// Generate ability keywords from constants\r\nconst ABILITY_KEYWORDS = generateAbilityKeywords();\r\n\r\nconst elementMap: Record<string, keyof typeof SUBCLASS_HASHES> = {\r\n    'void': 'VOID', 'sentinel': 'VOID', 'nightstalker': 'VOID', 'voidwalker': 'VOID',\r\n    'solar': 'SOLAR', 'sunbreaker': 'SOLAR', 'gunslinger': 'SOLAR', 'dawnblade': 'SOLAR',\r\n    'arc': 'ARC', 'striker': 'ARC', 'arcstrider': 'ARC', 'stormcaller': 'ARC',\r\n    'stasis': 'STASIS', 'behemoth': 'STASIS', 'revenant': 'STASIS', 'shadebinder': 'STASIS',\r\n    'strand': 'STRAND', 'berserker': 'STRAND', 'threadrunner': 'STRAND', 'broodweaver': 'STRAND',\r\n    'prismatic': 'PRISMATIC'\r\n};\r\n\r\n/**\r\n * Identify subclass identity by hash\r\n */\r\nexport function identifySubclassByHash(hash: number): string | undefined {\r\n    for (const [name, classes] of Object.entries(SUBCLASS_NAMES)) {\r\n        if (Object.values(classes).includes(hash)) {\r\n            // Check subclasses like 'sentinel' -> map to 'void'\r\n            return elementMap[name]?.toLowerCase() || name;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Resolve ability name to hash based on subclass and class\r\n */\r\nfunction resolveAbilityHash(abilityName: string, subclassName: string, guardianClass: 0 | 1 | 2, abilityType: 'grenade' | 'melee' | 'classAbility' | 'movement'): number {\r\n    const classKey = guardianClass === 0 ? 'TITAN' : guardianClass === 1 ? 'HUNTER' : 'WARLOCK';\r\n\r\n    // Map subclass name to element\r\n\r\n    const element = elementMap[subclassName.toLowerCase()];\r\n    if (!element) return 0;\r\n\r\n    const elementData = SUBCLASS_HASHES[element];\r\n    if (!elementData || !elementData[classKey]) return 0;\r\n\r\n    const classData = elementData[classKey];\r\n\r\n    // Convert ability name to constant format (e.g., \"storm grenade\" -> \"STORM\")\r\n    const constantName = abilityName.toUpperCase().replace(/ GRENADE$/, '').replace(/ /g, '_');\r\n\r\n    if (abilityType === 'grenade' && classData.GRENADES) {\r\n        return (classData.GRENADES as any)[constantName] || 0;\r\n    } else if (abilityType === 'melee' && classData.MELEE) {\r\n        return (classData.MELEE as any)[constantName] || 0;\r\n    } else if (abilityType === 'classAbility' && classData.CLASS_ABILITIES) {\r\n        return (classData.CLASS_ABILITIES as any)[constantName] || 0;\r\n    } else if (abilityType === 'movement' && classData.JUMPS) {\r\n        return (classData.JUMPS as any)[constantName] || 0;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Resolve aspect name to hash based on subclass and class\r\n * Automatically converts standard aspect hashes to Prismatic equivalents when needed\r\n */\r\nfunction resolveAspectHash(aspectName: string, subclassName: string, guardianClass: 0 | 1 | 2): number {\r\n    const classKey = guardianClass === 0 ? 'TITAN' : guardianClass === 1 ? 'HUNTER' : 'WARLOCK';\r\n    const isPrismatic = subclassName.toLowerCase() === 'prismatic';\r\n\r\n    // Map subclass name to element\r\n    const elementMap: Record<string, keyof typeof SUBCLASS_HASHES> = {\r\n        'void': 'VOID', 'sentinel': 'VOID', 'nightstalker': 'VOID', 'voidwalker': 'VOID',\r\n        'solar': 'SOLAR', 'sunbreaker': 'SOLAR', 'gunslinger': 'SOLAR', 'dawnblade': 'SOLAR',\r\n        'arc': 'ARC', 'striker': 'ARC', 'arcstrider': 'ARC', 'stormcaller': 'ARC',\r\n        'stasis': 'STASIS', 'behemoth': 'STASIS', 'revenant': 'STASIS', 'shadebinder': 'STASIS',\r\n        'strand': 'STRAND', 'berserker': 'STRAND', 'threadrunner': 'STRAND', 'broodweaver': 'STRAND',\r\n        'prismatic': 'PRISMATIC'\r\n    };\r\n\r\n    const constantName = aspectName.toUpperCase().replace(/ /g, '_');\r\n\r\n    // If Prismatic, try to find the aspect in Prismatic first\r\n    if (isPrismatic) {\r\n        const prismaticData = SUBCLASS_HASHES.PRISMATIC;\r\n        if (prismaticData && prismaticData[classKey] && prismaticData[classKey].ASPECTS) {\r\n            const hash = (prismaticData[classKey].ASPECTS as any)[constantName];\r\n            if (hash) return hash;\r\n        }\r\n    }\r\n\r\n    // Try to find in the specified element (or all elements if not found)\r\n    const element = elementMap[subclassName.toLowerCase()];\r\n    if (element && element !== 'PRISMATIC') {\r\n        const elementData = SUBCLASS_HASHES[element];\r\n        if (elementData && elementData[classKey] && elementData[classKey].ASPECTS) {\r\n            const standardHash = (elementData[classKey].ASPECTS as any)[constantName];\r\n            if (standardHash) {\r\n                // If we found a standard aspect and we're on Prismatic, convert it\r\n                if (isPrismatic) {\r\n                    return PRISMATIC_ASPECT_MAPPING[standardHash] || standardHash;\r\n                }\r\n                return standardHash;\r\n            }\r\n        }\r\n    }\r\n\r\n    // If not found and Prismatic, search all elements and convert\r\n    if (isPrismatic) {\r\n        const elements = ['VOID', 'SOLAR', 'ARC', 'STASIS', 'STRAND'] as const;\r\n        for (const elem of elements) {\r\n            const elemData = SUBCLASS_HASHES[elem];\r\n            if (elemData && elemData[classKey] && elemData[classKey].ASPECTS) {\r\n                const standardHash = (elemData[classKey].ASPECTS as any)[constantName];\r\n                if (standardHash) {\r\n                    return PRISMATIC_ASPECT_MAPPING[standardHash] || standardHash;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Resolve fragment name to hash based on element\r\n */\r\nfunction resolveFragmentHash(fragmentName: string, subclassName: string): number {\r\n    const element = subclassName ? elementMap[subclassName.toLowerCase()] : undefined;\r\n    const constantName = fragmentName.toUpperCase().replace(/ /g, '_');\r\n\r\n    // 1. Try to find in the specified element\r\n    if (element) {\r\n        const elementData = SUBCLASS_HASHES[element];\r\n        if (elementData && elementData.FRAGMENTS) {\r\n            const hash = (elementData.FRAGMENTS as any)[constantName];\r\n            if (hash) return hash;\r\n        }\r\n    }\r\n\r\n    // 2. Fallback: Search all elements (fragments are often unique across elements)\r\n    const elements = ['VOID', 'SOLAR', 'ARC', 'STASIS', 'STRAND', 'PRISMATIC'] as const;\r\n    for (const elem of elements) {\r\n        const elemData = SUBCLASS_HASHES[elem];\r\n        if (elemData && elemData.FRAGMENTS) {\r\n            const hash = (elemData.FRAGMENTS as any)[constantName];\r\n            if (hash) return hash;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Parse subclass configuration from natural language\r\n */\r\nexport function parseSubclassConfig(text: string, guardianClass: 0 | 1 | 2, currentSubclassHash?: number): SubclassConfig | null {\r\n    const lower = text.toLowerCase();\r\n    const config: SubclassConfig = {};\r\n\r\n    // Identify current subclass from hash\r\n    const currentSubclassName = currentSubclassHash ? identifySubclassByHash(currentSubclassHash) : undefined;\r\n\r\n    // PRIORITY 1: Detect Prismatic FIRST (highest priority)\r\n    // Check for \"prismatic\" keyword anywhere in the text\r\n    if (lower.includes('prismatic')) {\r\n        config.subclassName = 'prismatic';\r\n        const classKey = guardianClass === 0 ? 'titan' : guardianClass === 1 ? 'hunter' : 'warlock';\r\n        const hashes = SUBCLASS_NAMES['prismatic'];\r\n        if (hashes) {\r\n            config.subclassHash = hashes[classKey];\r\n        }\r\n    } else {\r\n        // PRIORITY 2: Detect subclass type - look for \"X subclass\" pattern\r\n        // This prevents false positives like \"solar grenade\" triggering \"solar subclass\"\r\n        const subclassPattern = /(void|solar|arc|stasis|strand|sentinel|nightstalker|voidwalker|sunbreaker|gunslinger|dawnblade|striker|arcstrider|stormcaller|behemoth|revenant|shadebinder|berserker|threadrunner|broodweaver)\\s+subclass/i;\r\n        const subclassMatch = text.match(subclassPattern);\r\n\r\n        if (subclassMatch) {\r\n            // Found explicit \"X subclass\" pattern\r\n            const subclassName = subclassMatch[1].toLowerCase();\r\n            config.subclassName = subclassName;\r\n            config.element = subclassName;\r\n\r\n            const classKey = guardianClass === 0 ? 'titan' : guardianClass === 1 ? 'hunter' : 'warlock';\r\n            const hashes = SUBCLASS_NAMES[subclassName];\r\n            if (hashes) {\r\n                config.subclassHash = hashes[classKey];\r\n            }\r\n        } else {\r\n            // PRIORITY 3: Check for standalone subclass class names (sentinel, nightstalker, etc.)\r\n            const classSpecificNames = ['sentinel', 'nightstalker', 'voidwalker', 'sunbreaker', 'gunslinger', 'dawnblade',\r\n                'striker', 'arcstrider', 'stormcaller', 'behemoth', 'revenant', 'shadebinder',\r\n                'berserker', 'threadrunner', 'broodweaver'];\r\n\r\n            for (const name of classSpecificNames) {\r\n                if (lower.includes(name)) {\r\n                    config.subclassName = name;\r\n                    // Map class-specific names back to elements\r\n                    const element = Object.entries(elementMap).find(([k]) => k === name)?.[1] || name;\r\n                    config.element = element.toLowerCase();\r\n                    const classKey = guardianClass === 0 ? 'titan' : guardianClass === 1 ? 'hunter' : 'warlock';\r\n                    const hashes = SUBCLASS_NAMES[name];\r\n                    if (hashes) {\r\n                        config.subclassHash = hashes[classKey];\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // PRIORITY 4: Check for element keywords ONLY with 'subclass' suffix\r\n            // This prevents \"equip solar\" (item) from being confused with \"solar subclass\"\r\n            if (!config.subclassName) {\r\n                const elementKeywords = ['void', 'solar', 'arc', 'stasis', 'strand'];\r\n                for (const element of elementKeywords) {\r\n                    if (lower.includes(`${element} subclass`)) {\r\n                        config.subclassName = element;\r\n                        config.element = element;\r\n                        const classKey = guardianClass === 0 ? 'titan' : guardianClass === 1 ? 'hunter' : 'warlock';\r\n                        const hashes = SUBCLASS_NAMES[element];\r\n                        if (hashes) {\r\n                            config.subclassHash = hashes[classKey];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Detect abilities (grenades, melees, etc.)\r\n    // For Prismatic, don't infer subclass from ability types\r\n\r\n    // Parse grenades FIRST with explicit pattern matching\r\n    const grenadePattern = /\\b(\\w+)\\s+grenade/i;\r\n    const grenadeMatch = text.match(grenadePattern);\r\n    if (grenadeMatch) {\r\n        const grenadeName = grenadeMatch[1].toLowerCase();\r\n        // Try to match grenade in ABILITY_KEYWORDS\r\n        for (const [ability, info] of Object.entries(ABILITY_KEYWORDS)) {\r\n            if (ability.includes(grenadeName) || info.keywords.some(k => k.includes(grenadeName + ' grenade'))) {\r\n                config.grenade = ability;\r\n                if (!config.element) config.element = info.element;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Then parse other abilities (aspects, fragments)\r\n    for (const [ability, info] of Object.entries(ABILITY_KEYWORDS)) {\r\n        for (const keyword of info.keywords) {\r\n            if (lower.includes(keyword)) {\r\n                // Skip if already matched as grenade\r\n                if (config.grenade === ability) {\r\n                    continue;\r\n                }\r\n\r\n                // Categorize by ability type\r\n                const abilityLower = ability.toLowerCase();\r\n\r\n                // 1. Check for fragment prefixes (all element types)\r\n                const fragmentPrefixes = ['echo of', 'ember of', 'spark of', 'whisper of', 'thread of', 'facet of'];\r\n                const isFragment = fragmentPrefixes.some(prefix => abilityLower.includes(prefix));\r\n\r\n                if (isFragment) {\r\n                    if (!config.fragments) config.fragments = [];\r\n                    if (!config.fragments.includes(ability)) {\r\n                        config.fragments.push(ability);\r\n                    }\r\n                    if (!config.element) config.element = info.element;\r\n                }\r\n                // 2. Check for Jumps/Movement\r\n                else if (info.keywords.some(k => k.includes('jump') || k.includes('glide') || k.includes('lift') || k.includes('blink'))) {\r\n                    config.jump = ability;\r\n                    if (!config.element) config.element = info.element;\r\n                }\r\n                // 3. Detect Melees (NEW: Smarter check)\r\n                else if (abilityLower.includes('melee') || abilityLower.includes('strike') || abilityLower.includes('snap') ||\r\n                    abilityLower.includes('throw') || abilityLower.includes('blow') || abilityLower.includes('spike')) {\r\n                    config.melee = ability;\r\n                    if (!config.element) config.element = info.element;\r\n                }\r\n                // 4. Detect Supers (NEW: Keywords or common 슈퍼 names)\r\n                else if (abilityLower.includes('dawn') || abilityLower.includes('hammer') || abilityLower.includes('well') ||\r\n                    abilityLower.includes('nova') || abilityLower.includes('fist') || abilityLower.includes('blade') ||\r\n                    abilityLower.includes('storm')) {\r\n                    config.super = ability;\r\n                    if (!config.element) config.element = info.element;\r\n                }\r\n                // 5. Default to Aspect\r\n                else {\r\n                    const isGrenadeName = keyword.endsWith(' grenade');\r\n                    if (!isGrenadeName) {\r\n                        if (!config.aspects) config.aspects = [];\r\n                        if (!config.aspects.includes(ability)) {\r\n                            config.aspects.push(ability);\r\n                        }\r\n                        if (!config.element) config.element = info.element;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // CRITICAL FIX: Convert ability names to hashes\r\n    // Priority: Explicitly requested > Inferred from abilities > Current character context\r\n    const resolutionContextName = config.subclassName || config.element || currentSubclassName;\r\n\r\n    if (resolutionContextName) {\r\n        if (config.grenade && typeof config.grenade === 'string') {\r\n            const grenadeHash = resolveAbilityHash(config.grenade, resolutionContextName, guardianClass, 'grenade');\r\n            if (grenadeHash) config.grenade = grenadeHash;\r\n        }\r\n        if (config.melee && typeof config.melee === 'string') {\r\n            const meleeHash = resolveAbilityHash(config.melee, resolutionContextName, guardianClass, 'melee');\r\n            if (meleeHash) config.melee = meleeHash;\r\n        }\r\n        if (config.classAbility && typeof config.classAbility === 'string') {\r\n            const classAbilityHash = resolveAbilityHash(config.classAbility, resolutionContextName, guardianClass, 'classAbility');\r\n            if (classAbilityHash) config.classAbility = classAbilityHash;\r\n        }\r\n        if (config.super && typeof config.super === 'string') {\r\n            const superHash = resolveAbilityHash(config.super, resolutionContextName, guardianClass, 'super' as any);\r\n            if (superHash) config.super = superHash.toString();\r\n        }\r\n        if (config.jump && typeof config.jump === 'string') {\r\n            const jumpHash = resolveAbilityHash(config.jump, resolutionContextName, guardianClass, 'movement');\r\n            if (jumpHash) config.jump = jumpHash;\r\n        }\r\n\r\n        // Convert aspect names to hashes (with Prismatic conversion)\r\n        if (config.aspects && config.aspects.length > 0) {\r\n            config.aspects = config.aspects.map(aspectName => {\r\n                const hash = resolveAspectHash(aspectName, resolutionContextName, guardianClass);\r\n                return hash ? hash.toString() : aspectName;\r\n            });\r\n        }\r\n        // Convert fragment names to hashes\r\n        if (config.fragments && config.fragments.length > 0) {\r\n            config.fragments = config.fragments.map(fragmentName => {\r\n                const hash = resolveFragmentHash(fragmentName, resolutionContextName);\r\n                return hash ? hash.toString() : fragmentName;\r\n            });\r\n        }\r\n    }\r\n\r\n    // If no explicit subclass was mentioned but abilities were found\r\n    // Don't auto-infer subclass - let the player specify it explicitly\r\n    // This prevents \"storm grenade\" from auto-selecting Arc when they might want Prismatic\r\n\r\n    return Object.keys(config).length > 0 ? config : null;\r\n}\r\n\r\n/**\r\n * Check if text contains subclass-related keywords\r\n */\r\nexport function containsSubclassKeywords(text: string): boolean {\r\n    const lower = text.toLowerCase();\r\n\r\n    // Check for Prismatic first (highest priority)\r\n    if (lower.includes('prismatic')) return true;\r\n\r\n    // Check for explicit \"X subclass\" pattern (Mandatory for generic elements)\r\n    const subclassPattern = /(void|solar|arc|stasis|strand)\\s+subclass/i;\r\n    if (text.match(subclassPattern)) return true;\r\n\r\n    // Check for class-specific subclass names (Allowed standalone as they are unique identities)\r\n    const classSpecificNames = ['sentinel', 'nightstalker', 'voidwalker', 'sunbreaker', 'gunslinger', 'dawnblade',\r\n        'striker', 'arcstrider', 'stormcaller', 'behemoth', 'revenant', 'shadebinder',\r\n        'berserker', 'threadrunner', 'broodweaver'];\r\n    for (const name of classSpecificNames) {\r\n        if (lower.includes(name)) return true;\r\n    }\r\n\r\n    // Check for ability keywords (Specific context)\r\n    const abilityIndicators = ['aspect', 'fragment', 'super', 'subclass'];\r\n    for (const indicator of abilityIndicators) {\r\n        if (lower.includes(indicator)) return true;\r\n    }\r\n\r\n    // Check for specific aspect/fragment names from ABILITY_KEYWORDS\r\n    for (const info of Object.values(ABILITY_KEYWORDS)) {\r\n        for (const keyword of info.keywords) {\r\n            // Only count it if it's a specific enough string (e.g. > 4 chars) to avoid false positives with common words\r\n            if (keyword.length > 5 && lower.includes(keyword)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Note: Generic terms like 'grenade' or 'melee' are NO LONGER direct subclass triggers\r\n    // to avoid \"Equip Solar Grenade\" being treated as a full subclass change.\r\n\r\n    return false;\r\n}\r\n\r\nexport const subclassParserService = {\r\n    parseSubclassConfig,\r\n    identifySubclassByHash,\r\n    containsSubclassKeywords,\r\n    getAbilityElement: (name: string) => ABILITY_KEYWORDS[name.toLowerCase()]?.element,\r\n    resolveAbilityHash,\r\n    resolveAspectHash,\r\n    resolveFragmentHash\r\n};\r\n","/**\r\n * Agent Command Parser Service\r\n * Handles natural language command interpretation for the ExoSync agent\r\n */\r\nimport { subclassParserService } from './subclass-parser.service';\r\n\r\nexport interface CommandResult {\r\n    type: 'navigation' | 'action' | 'unknown';\r\n    target?: string;\r\n    message: string;\r\n    success: boolean;\r\n    actionType?: 'equip' | 'loadout';\r\n    actionPayload?: any;\r\n}\r\n\r\ninterface NavigationCommand {\r\n    keywords: string[];\r\n    route: string;\r\n    name: string;\r\n}\r\n\r\nconst NAVIGATION_COMMANDS: NavigationCommand[] = [\r\n    {\r\n        keywords: ['builds', 'build', 'vault', 'loadout vault', 'optimizer', 'loadouts'],\r\n        route: '/builds',\r\n        name: 'Builds'\r\n    },\r\n    {\r\n        keywords: ['galaxy', 'synergy galaxy', 'synergies', 'builder'],\r\n        route: '/galaxy',\r\n        name: 'Synergy Galaxy'\r\n    },\r\n    {\r\n        keywords: ['settings', 'setting', 'preferences', 'config', 'configuration'],\r\n        route: '/settings',\r\n        name: 'Settings'\r\n    },\r\n    {\r\n        keywords: ['generator', 'random', 'chaos', 'generate', 'randomize'],\r\n        route: '/generator',\r\n        name: 'Generator'\r\n    },\r\n    {\r\n        keywords: ['saved builds', 'saved', 'my builds', 'personal builds'],\r\n        route: '/saved-builds',\r\n        name: 'Saved Builds'\r\n    },\r\n    {\r\n        keywords: ['home', 'main', 'start', 'beginning', 'menu'],\r\n        route: '/',\r\n        name: 'Home'\r\n    },\r\n    {\r\n        keywords: ['credits', 'about', 'info', 'information'],\r\n        route: '/credits',\r\n        name: 'Credits'\r\n    }\r\n];\r\n\r\nconst NAVIGATION_TRIGGERS = [\r\n    'go to', 'goto', 'open', 'show', 'show me', 'take me to', 'navigate to',\r\n    'load', 'launch', 'start', 'bring up', 'head to', 'switch to',\r\n    'display', 'view', 'see', 'check', 'look at'\r\n];\r\n\r\nconst EQUIP_TRIGGERS = [\r\n    'equip', 'wear', 'put on', 'use', 'switch to'\r\n];\r\n\r\n// Natural language patterns for equipping\r\nconst NATURAL_EQUIP_PATTERNS = [\r\n    /^i want to (?:equip|use|wear|run)\\s+(.+)$/i,\r\n    /^lets? (?:equip|use|wear|run)\\s+(.+)$/i,\r\n    /^can you (?:equip|use|wear)\\s+(.+)$/i,\r\n    /^(?:equip|use|wear|run)\\s+(.+)$/i,\r\n];\r\n\r\n/**\r\n * Normalizes input text for matching\r\n */\r\nfunction normalizeInput(input: string): string {\r\n    return input\r\n        .toLowerCase()\r\n        .replace(/[^a-z0-9\\s]/g, '') // Remove special chars\r\n        .replace(/\\s+/g, ' ') // Normalize whitespace\r\n        .trim();\r\n}\r\n\r\n/**\r\n * Checks if the input is a DIM share link or loadout link\r\n */\r\nfunction isDIMLink(input: string): boolean {\r\n    // Accept dim.gg share links and destinyitemmanager.com URLs\r\n    // This includes both loadout share links and profile page links\r\n    // The loadout-link.service will handle validation and provide helpful errors\r\n    return input.includes('dim.gg/') || input.includes('destinyitemmanager.com');\r\n}\r\n\r\n/**\r\n * Parses an equip command and extracts the item names or hashes (supports multiple items)\r\n */\r\nfunction parseEquipCommand(normalized: string, original: string): { items: Array<{ itemIdentifier: string; isHash: boolean }> } | null {\r\n    const lowerOriginal = original.toLowerCase().trim();\r\n\r\n    // Try to match equip triggers\r\n    for (const trigger of EQUIP_TRIGGERS) {\r\n        const triggerNormalized = normalizeInput(trigger);\r\n\r\n        // Check if command starts with the trigger\r\n        if (normalized.startsWith(triggerNormalized)) {\r\n            // Extract everything after the trigger\r\n            const afterTrigger = lowerOriginal.substring(trigger.length).trim();\r\n            if (afterTrigger) {\r\n                // Split by comma, \"and\", or \"with\" for multiple items\r\n                const normalizedString = afterTrigger\r\n                    .replace(/\\s+and\\s+/gi, ',')\r\n                    .replace(/\\s+with\\s+/gi, ',');\r\n                const itemStrings = normalizedString.split(',').map(s => s.trim()).filter(s => s.length > 0);\r\n                const items = itemStrings.map(itemStr => {\r\n                    // Check if it's a hash (all digits)\r\n                    const isHash = /^\\d+$/.test(itemStr);\r\n                    return { itemIdentifier: itemStr, isHash };\r\n                });\r\n                return { items };\r\n            }\r\n        }\r\n\r\n        // Also check with the normalized string to handle edge cases\r\n        if (normalized.includes(triggerNormalized)) {\r\n            const parts = normalized.split(triggerNormalized);\r\n            if (parts.length > 1 && parts[1].trim()) {\r\n                // Reconstruct from original to preserve capitalization\r\n                const afterIndex = lowerOriginal.indexOf(trigger) + trigger.length;\r\n                const itemsString = original.substring(afterIndex).trim();\r\n                if (itemsString) {\r\n                    // Split by comma, \"and\", or \"with\" for multiple items\r\n                    const normalizedString = itemsString\r\n                        .replace(/\\s+and\\s+/gi, ',')\r\n                        .replace(/\\s+with\\s+/gi, ',');\r\n                    const itemStrings = normalizedString.split(',').map(s => s.trim()).filter(s => s.length > 0);\r\n                    const items = itemStrings.map(itemStr => {\r\n                        // Check if it's a hash (all digits)\r\n                        const isHash = /^\\d+$/.test(itemStr);\r\n                        return { itemIdentifier: itemStr, isHash };\r\n                    });\r\n                    return { items };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parses a navigation command\r\n */\r\nfunction parseNavigationCommand(normalized: string): NavigationCommand | null {\r\n    // Check for direct keyword matches\r\n    for (const cmd of NAVIGATION_COMMANDS) {\r\n        for (const keyword of cmd.keywords) {\r\n            const keywordNormalized = normalizeInput(keyword); // Apply same normalization!\r\n\r\n            // Direct match (e.g., \"builds\")\r\n            if (normalized === keywordNormalized) {\r\n                return cmd;\r\n            }\r\n\r\n            // Check if normalized input contains the keyword\r\n            if (normalized.includes(keywordNormalized)) {\r\n                return cmd;\r\n            }\r\n\r\n            // With navigation trigger (e.g., \"go to builds\" -> \"gotobuilds\")\r\n            for (const trigger of NAVIGATION_TRIGGERS) {\r\n                const triggerNormalized = normalizeInput(trigger);\r\n                const fullCommand = triggerNormalized + keywordNormalized;\r\n\r\n                if (normalized === fullCommand ||\r\n                    normalized.startsWith(fullCommand) ||\r\n                    normalized.endsWith(fullCommand)) {\r\n                    return cmd;\r\n                }\r\n            }\r\n\r\n            // With common suffixes (e.g., \"builds page\" -> \"buildspage\")\r\n            const suffixes = ['page', 'screen', 'view', 'mode', 'tab'];\r\n            for (const suffix of suffixes) {\r\n                if (normalized === `${keywordNormalized}${suffix}` ||\r\n                    normalized.startsWith(`${keywordNormalized}${suffix}`) ||\r\n                    normalized.endsWith(`${keywordNormalized}${suffix}`)) {\r\n                    return cmd;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Main command parser - interprets user input and returns appropriate action\r\n */\r\nexport function parseCommand(input: string): CommandResult {\r\n    const trimmed = input.trim();\r\n\r\n    if (!trimmed) {\r\n        return {\r\n            type: 'unknown',\r\n            message: 'Please enter a command.',\r\n            success: false\r\n        };\r\n    }\r\n\r\n    // Check for DIM links first\r\n    if (isDIMLink(trimmed)) {\r\n        const encodedUrl = encodeURIComponent(trimmed);\r\n        return {\r\n            type: 'navigation',\r\n            target: `/dim-loadout?url=${encodedUrl}`,\r\n            message: 'DIM loadout detected. Loading build analysis...',\r\n            success: true\r\n        };\r\n    }\r\n\r\n    // Check for natural language equip patterns first\r\n    for (const pattern of NATURAL_EQUIP_PATTERNS) {\r\n        const match = trimmed.match(pattern);\r\n        if (match && match[1]) {\r\n            const itemsString = match[1].trim();\r\n\r\n            // Check if this includes subclass configuration\r\n            const hasSubclass = subclassParserService.containsSubclassKeywords(itemsString);\r\n\r\n            // Split by comma, \"and\", or \"with\" for multiple items\r\n            // First replace \" and \" and \" with \" with commas, then split by comma\r\n            const normalizedString = itemsString\r\n                .replace(/\\s+and\\s+/gi, ',')\r\n                .replace(/\\s+with\\s+/gi, ',');\r\n            const itemStrings = normalizedString.split(',').map(s => s.trim()).filter(s => s.length > 0);\r\n\r\n            const items = itemStrings.map(itemStr => {\r\n                // Check if it's a hash (all digits)\r\n                const isHash = /^\\d+$/.test(itemStr);\r\n                return { itemIdentifier: itemStr, isHash };\r\n            });\r\n\r\n            if (hasSubclass) {\r\n                // This is a full loadout with subclass config\r\n                return {\r\n                    type: 'action',\r\n                    message: `Configuring loadout...`,\r\n                    success: true,\r\n                    actionType: 'loadout',\r\n                    actionPayload: {\r\n                        items,\r\n                        subclassText: itemsString\r\n                    }\r\n                };\r\n            } else {\r\n                // Just equipping items\r\n                const itemCount = items.length;\r\n                const displayText = itemCount === 1\r\n                    ? (items[0].isHash ? `item hash ${items[0].itemIdentifier}` : items[0].itemIdentifier)\r\n                    : `${itemCount} items`;\r\n\r\n                return {\r\n                    type: 'action',\r\n                    message: `Searching for ${displayText}...`,\r\n                    success: true,\r\n                    actionType: 'equip',\r\n                    actionPayload: { items }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check for traditional equip commands\r\n    const normalized = normalizeInput(trimmed);\r\n    const equipCommand = parseEquipCommand(normalized, trimmed);\r\n\r\n    if (equipCommand) {\r\n        const itemCount = equipCommand.items.length;\r\n        const displayText = itemCount === 1\r\n            ? (equipCommand.items[0].isHash\r\n                ? `item hash ${equipCommand.items[0].itemIdentifier}`\r\n                : equipCommand.items[0].itemIdentifier)\r\n            : `${itemCount} items`;\r\n\r\n        return {\r\n            type: 'action',\r\n            message: `Searching for ${displayText}...`,\r\n            success: true,\r\n            actionType: 'equip',\r\n            actionPayload: {\r\n                items: equipCommand.items\r\n            }\r\n        };\r\n    }\r\n\r\n    // Check for navigation commands\r\n    const navCommand = parseNavigationCommand(normalized);\r\n\r\n    if (navCommand) {\r\n        return {\r\n            type: 'navigation',\r\n            target: navCommand.route,\r\n            message: `Routing to ${navCommand.name}...`,\r\n            success: true\r\n        };\r\n    }\r\n\r\n    // Unknown command\r\n    return {\r\n        type: 'unknown',\r\n        message: \"I don't understand that command yet. Try: 'equip [item name]', 'go to builds', 'open galaxy', or paste a DIM link.\",\r\n        success: false\r\n    };\r\n}\r\n\r\n/**\r\n * Gets command suggestions based on partial input\r\n */\r\nexport function getCommandSuggestions(input: string): string[] {\r\n    if (!input.trim()) {\r\n        return [];\r\n    }\r\n\r\n    const normalized = normalizeInput(input);\r\n    const suggestions: string[] = [];\r\n\r\n    // Match against navigation commands\r\n    for (const cmd of NAVIGATION_COMMANDS) {\r\n        for (const keyword of cmd.keywords) {\r\n            if (keyword.toLowerCase().includes(normalized)) {\r\n                suggestions.push(`Go to ${cmd.name}`);\r\n                break; // Only add once per command\r\n            }\r\n        }\r\n    }\r\n\r\n    return suggestions.slice(0, 5); // Limit to 5 suggestions\r\n}\r\n","import React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useAuthStore, useProfileStore } from '../store';\nimport { itemSearchService } from '../services/item-search.service';\nimport { transferService } from '../services/bungie/transfer.service';\nimport { profileLoader } from '../services/bungie/profile.service';\nimport { parseCommand } from '../services/agent-command.service';\nimport { subclassParserService } from '../services/subclass-parser.service';\nimport { BUCKET_HASHES } from '../config/bungie.config';\nimport { ElementType, GuardianClass, ItemSlot, type BuildTemplate } from '../types';\nimport './AgentWakePage.css';\n\nexport function AgentWakePage() {\n    const navigate = useNavigate();\n    const [input, setInput] = useState('');\n    const [response, setResponse] = useState('');\n    const [isProcessing, setIsProcessing] = useState(false);\n    const { selectedCharacterId } = useProfileStore();\n    const { isAuthenticated } = useAuthStore();\n    const state = useProfileStore.getState();\n    const character = state.characters.find(c => c.characterId === selectedCharacterId) || state.characters[0];\n\n    const handleSingleEquip = async (itemIdentifier: string, isHash: boolean) => {\n        try {\n            if (!isAuthenticated) {\n                setResponse('Please log in to Bungie to equip items. Authenticate using the button in the top right.');\n                return;\n            }\n\n            if (!selectedCharacterId) {\n                setResponse('Please select a character first.');\n                return;\n            }\n\n            // NOTICE: Removed intermediate \"Syncing...\" and \"Searching...\" responses to reduce UI flicker\n            await profileLoader.loadProfile(true);\n\n            let searchResult;\n            if (isHash) {\n                const itemHash = parseInt(itemIdentifier, 10);\n                searchResult = await itemSearchService.findItemByHash(itemHash);\n            } else {\n                searchResult = await itemSearchService.findItemByName(itemIdentifier);\n            }\n\n            if (!searchResult) {\n                // If it's not a physical item, check if it's a subclass component (aspect/fragment)\n                const isSubclassComponent = subclassParserService.containsSubclassKeywords(itemIdentifier);\n                if (isSubclassComponent) {\n                    // It's a subclass component, proceed to subclassConfig parsing\n                } else {\n                    setResponse(`Could not find \"${itemIdentifier}\" in your inventory.`);\n                    return;\n                }\n            }\n\n            const definition = searchResult?.definition;\n            const item = searchResult?.item;\n            const isExotic = item?.tierType === 6;\n\n            const template: any = {\n                name: definition ? `Agent: ${definition.displayProperties.name}` : `Agent: Subclass Config`,\n                element: ElementType.Solar,\n                items: (item && definition && !isExotic) ? [{ hash: item.itemHash, name: definition.displayProperties.name }] : []\n            };\n\n            if (item && definition) {\n                if (isExotic) {\n                    if (definition.itemType === 3) template.exoticWeapon = { hash: item.itemHash, name: definition.displayProperties.name, slot: ItemSlot.Kinetic };\n                    if (definition.itemType === 2) template.exoticArmor = { hash: item.itemHash, name: definition.displayProperties.name, slot: ItemSlot.Helmet };\n                }\n            }\n\n            // Determine current subclass for context\n            const currentSubclassItem = (state.characterEquipment?.[selectedCharacterId] || [])\n                .find(i => i.bucketHash === BUCKET_HASHES.SUBCLASS);\n            const currentSubclassHash = currentSubclassItem?.itemHash;\n\n            // Parse subclass configuration\n            const subclassConfig = subclassParserService.parseSubclassConfig(itemIdentifier, character.classType);\n\n            // ENFORCE EXPLICIT SUBCLASS: If abilities were found but no explicit subclass name was mentioned\n            if (subclassConfig && !subclassConfig.subclassName) {\n                setResponse(\"Please specify the subclass, e.g. 'equip prismatic subclass with hellion and feed the void'\");\n                return;\n            }\n\n            const currentSubclassName = currentSubclassHash ? subclassParserService.identifySubclassByHash(currentSubclassHash) : undefined;\n            let targetElement = subclassConfig?.element || currentSubclassName;\n\n            const config = subclassConfig ? {\n                ...subclassConfig,\n                aspects: subclassConfig.aspects?.map(a => typeof a === 'string' ? parseInt(a, 10) || 0 : a).filter(a => a !== 0),\n                fragments: subclassConfig.fragments?.map(f => typeof f === 'string' ? parseInt(f, 10) || 0 : f).filter(f => f !== 0),\n                superHash: typeof subclassConfig.super === 'string' ? parseInt(subclassConfig.super, 10) || 0 : subclassConfig.super,\n                grenadeHash: typeof subclassConfig.grenade === 'number' ? subclassConfig.grenade : undefined,\n                meleeHash: typeof subclassConfig.melee === 'number' ? subclassConfig.melee : undefined,\n                classAbilityHash: typeof subclassConfig.classAbility === 'number' ? subclassConfig.classAbility : undefined,\n                jumpHash: typeof (subclassConfig as any).jump === 'number' ? (subclassConfig as any).jump : undefined,\n            } : undefined;\n\n            if (subclassConfig && config) {\n                template.element = (targetElement as ElementType) || ElementType.Neutral;\n                template.subclassConfig = config;\n                template.skipSubclassSwap = !!targetElement && targetElement === currentSubclassName;\n            } else {\n                template.element = ElementType.Neutral;\n                template.skipSubclassSwap = true;\n            }\n\n            let actionText = config ? (definition ? `Equipping ${definition.displayProperties.name} and configuring subclass...` : `Configuring subclass abilities...`) : `Equipping ${definition?.displayProperties.name} now...`;\n\n            // NOTICE: Inform user about explicit subclass naming if missing\n            if (subclassConfig && !subclassConfig.subclassName) {\n                actionText = `Note: For best results, specify the subclass (e.g. 'equip prismatic subclass with hellion'). ${actionText}`;\n            }\n\n            setResponse(actionText);\n\n            // Navigate early so user can watch transmats\n            navigate('/galaxy');\n\n            const result = await transferService.equipBuild(template, selectedCharacterId);\n\n            if (result.success) {\n                setResponse(result.error || `${definition?.displayProperties.name || 'Item'} equipped!`);\n            } else {\n                setResponse(`Failed to equip: ${result.error || 'Unknown error'}`);\n            }\n\n        } catch (error) {\n            setResponse(`Error: ${error instanceof Error ? error.message : 'Unknown'}`);\n        }\n    };\n\n    const handleBatchEquip = async (items: Array<{ itemIdentifier: string; isHash: boolean }>) => {\n        try {\n            if (!isAuthenticated) {\n                setResponse('Login required to pull items. Please authenticate with Bungie first.');\n                return;\n            }\n\n            if (!selectedCharacterId) {\n                setResponse('Please select a character.');\n                return;\n            }\n\n            // NOTICE: Removed intermediate \"Syncing...\" response\n            await profileLoader.loadProfile(true);\n\n            const searchResults = [];\n            for (const { itemIdentifier, isHash } of items) {\n                let searchResult;\n                if (isHash) {\n                    searchResult = await itemSearchService.findItemByHash(parseInt(itemIdentifier, 10));\n                } else {\n                    searchResult = await itemSearchService.findItemByName(itemIdentifier);\n                }\n\n                if (!searchResult) {\n                    const isSubclassComponent = subclassParserService.containsSubclassKeywords(itemIdentifier);\n                    if (!isSubclassComponent) {\n                        setResponse(`Could not find \"${itemIdentifier}\" in your inventory.`);\n                        return;\n                    }\n                    // Skip adding for subclass components in batch (they are handled by subclassConfig later)\n                    continue;\n                }\n                searchResults.push(searchResult);\n            }\n\n            if (searchResults.length === 0 && !subclassParserService.containsSubclassKeywords(items.map(i => i.itemIdentifier).join(' '))) {\n                setResponse('No items or subclass components found to equip.');\n                return;\n            }\n\n            const itemNames = searchResults.map(r => r.definition.displayProperties.name).join(', ');\n            setResponse(`Pulling items now... (${itemNames})`);\n\n            // Navigate early so user can watch transmats\n            navigate('/galaxy');\n\n            const weapons = searchResults.filter(r => r.definition.itemType === 3);\n            const armor = searchResults.filter(r => r.definition.itemType === 2);\n            const exoticWeapon = weapons.find(r => r.definition.inventory?.tierType === 6);\n            const exoticArmor = armor.find(r => r.definition.inventory?.tierType === 6);\n            const legendaryItems = searchResults.filter(r => r.definition.inventory?.tierType !== 6);\n\n            const detectElement = (results: any[]) => {\n                const exoticW = results.find(r => r.definition.itemType === 3 && r.definition.inventory?.tierType === 6);\n                if (exoticW) {\n                    const dt = exoticW.definition.defaultDamageType;\n                    if (dt === 2) return ElementType.Arc;\n                    if (dt === 3) return ElementType.Solar;\n                    if (dt === 4) return ElementType.Void;\n                    if (dt === 6) return ElementType.Stasis;\n                    if (dt === 7) return ElementType.Strand;\n                }\n                return ElementType.Neutral;\n            };\n\n            const buildTemplate: BuildTemplate = {\n                id: `agent-batch-${Date.now()}`,\n                name: `Agent Batch: ${itemNames}`,\n                element: detectElement(searchResults),\n                guardianClass: searchResults[0].definition.classType as GuardianClass,\n                exoticWeapon: exoticWeapon ? { hash: exoticWeapon.item.itemHash, name: exoticWeapon.definition.displayProperties.name, slot: ItemSlot.Kinetic } : undefined,\n                exoticArmor: exoticArmor ? { hash: exoticArmor.item.itemHash, name: exoticArmor.definition.displayProperties.name, slot: ItemSlot.Helmet } : undefined,\n                items: legendaryItems.map(r => ({ hash: r.item.itemHash, name: r.definition.displayProperties.name })),\n                subclassConfig: undefined,\n                playstyle: 'Agent Loadout',\n                difficulty: 'intermediate',\n                armorMods: [],\n                skipSubclassSwap: true // Batch identify should never change subclass\n            };\n\n            const result = await transferService.equipBuild(\n                buildTemplate,\n                selectedCharacterId\n            );\n\n            if (result.success) {\n                setResponse(result.error || `Successfully equipped ${itemNames}!`);\n            } else {\n                setResponse(`Failed: ${result.error || 'Check inventory space'}`);\n            }\n        } catch (error) {\n            setResponse(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    };\n\n    const handleLoadoutAction = async (items: Array<{ itemIdentifier: string; isHash: boolean }>, resultPayload: any) => {\n        try {\n            if (!isAuthenticated) {\n                setResponse('Login required. Please authenticate first.');\n                return;\n            }\n\n            if (!selectedCharacterId) {\n                setResponse('Character ID not found.');\n                return;\n            }\n\n            await profileLoader.loadProfile(true);\n            const newState = useProfileStore.getState();\n            const character = newState.getSelectedCharacter();\n            if (!character) {\n                setResponse('Could not find character information.');\n                return;\n            }\n\n            const configRaw = resultPayload.subclassText ? subclassParserService.parseSubclassConfig(resultPayload.subclassText, character.classType) : null;\n\n            let responseText = `Configuring loadout...`;\n            if (configRaw && !configRaw.subclassName) {\n                responseText = `Note: For best results, specify the subclass (e.g. 'equip prismatic subclass with hellion'). Configuring loadout...`;\n            }\n            setResponse(responseText);\n\n            const searchResults = [];\n            for (const { itemIdentifier, isHash } of items) {\n                let searchResult;\n                if (isHash) {\n                    searchResult = await itemSearchService.findItemByHash(parseInt(itemIdentifier, 10));\n                } else {\n                    searchResult = await itemSearchService.findItemByName(itemIdentifier);\n                }\n                if (searchResult) searchResults.push(searchResult);\n            }\n\n            const weapons = searchResults.filter(r => r.definition.itemType === 3);\n            const armor = searchResults.filter(r => r.definition.itemType === 2);\n            const exoticWeapon = weapons.find(r => r.definition.inventory?.tierType === 6);\n            const exoticArmor = armor.find(r => r.definition.inventory?.tierType === 6);\n            const legendaryItems = searchResults.filter(r => r.definition.inventory?.tierType !== 6);\n\n            // Determine current subclass for context (reused logic)\n            const currentSubclassItem = (newState.characterEquipment?.[selectedCharacterId] || [])\n                .find(i => i.bucketHash === BUCKET_HASHES.SUBCLASS);\n            const currentSubclassHash = currentSubclassItem?.itemHash;\n            const currentSubclassName = currentSubclassHash ? subclassParserService.identifySubclassByHash(currentSubclassHash) : undefined;\n\n\n            // Map SubclassConfig to match BuildTemplate expectations\n            const config = configRaw ? {\n                ...configRaw,\n                aspects: configRaw.aspects?.map(a => typeof a === 'string' ? parseInt(a, 10) || 0 : a).filter(a => a !== 0),\n                fragments: configRaw.fragments?.map(f => typeof f === 'string' ? parseInt(f, 10) || 0 : f).filter(f => f !== 0),\n                grenadeHash: typeof configRaw.grenade === 'number' ? configRaw.grenade : undefined,\n                meleeHash: typeof configRaw.melee === 'number' ? configRaw.melee : undefined,\n                classAbilityHash: typeof configRaw.classAbility === 'number' ? configRaw.classAbility : undefined,\n                jumpHash: typeof (configRaw as any).jump === 'number' ? (configRaw as any).jump : undefined,\n            } : null;\n\n            // Determine target element: Explicit -> Current -> Neutral\n            let targetElement = (configRaw?.subclassName as ElementType) ||\n                (currentSubclassName as ElementType || ElementType.Neutral);\n\n            // PRISMATIC STICKY LOGIC: If we are on Prismatic, and the abilities are compatible, STAY on Prismatic\n            if (currentSubclassName === 'prismatic' && !configRaw?.subclassName) {\n                let compatibleWithPrismatic = true;\n\n                // Check if aspects are in Prismatic\n                if (configRaw?.aspects) {\n                    for (const aspect of configRaw.aspects) {\n                        const hash = subclassParserService.resolveAspectHash(aspect, 'prismatic', character.classType);\n                        if (!hash) compatibleWithPrismatic = false;\n                    }\n                }\n\n                // Check if Super is in Prismatic\n                if (configRaw?.super) {\n                    const hash = subclassParserService.resolveAbilityHash(configRaw.super, 'prismatic', character.classType, 'super' as any);\n                    if (!hash) compatibleWithPrismatic = false;\n                }\n\n                if (compatibleWithPrismatic) {\n                    targetElement = 'prismatic' as ElementType;\n                }\n            }\n\n            // Only skip swap if NO config, OR if we are targeting current subclass (implicit or explicit match)\n            const isSameSubclass = targetElement === currentSubclassName;\n            const skipSwap = !config || (isSameSubclass && !configRaw?.subclassName); // Skip if no config, or if we are applying to current (and didn't explicitly ask for it)\n\n            const buildTemplate: BuildTemplate = {\n                id: `agent-loadout-${Date.now()}`,\n                name: 'Agent Loadout',\n                element: targetElement,\n                guardianClass: character.classType,\n                exoticWeapon: exoticWeapon ? { hash: exoticWeapon.item.itemHash, name: exoticWeapon.definition.displayProperties.name, slot: ItemSlot.Kinetic } : undefined,\n                exoticArmor: exoticArmor ? { hash: exoticArmor.item.itemHash, name: exoticArmor.definition.displayProperties.name, slot: ItemSlot.Helmet } : undefined,\n                items: legendaryItems.map(r => ({ hash: r.item.itemHash, name: r.definition.displayProperties.name })),\n                subclassConfig: config || undefined,\n                playstyle: 'Agent Configured',\n                difficulty: 'advanced',\n                armorMods: [],\n                skipSubclassSwap: skipSwap\n            };\n\n            setResponse(`Applying loadout now... (${buildTemplate.element} subclass)`);\n\n            // Navigate early so user can watch transmats\n            navigate('/galaxy');\n\n            const result = await transferService.equipBuild(\n                buildTemplate,\n                selectedCharacterId\n            );\n\n            if (result.success) {\n                setResponse(result.error || `Loadout successfully applied!`);\n            } else {\n                setResponse(`Failed: ${result.error || 'Unknown error'}`);\n            }\n\n        } catch (error) {\n            setResponse(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    };\n\n    const handleSubmit = async (e: React.FormEvent) => {\n        e.preventDefault();\n        const trimmed = input.trim();\n        if (!trimmed || isProcessing) return;\n\n        const result = parseCommand(trimmed);\n        setResponse(result.message);\n        setInput('');\n\n        if (result.success && result.target) {\n            setTimeout(() => navigate(result.target!), 800);\n            return;\n        }\n\n        if (result.success && result.type === 'action') {\n            setIsProcessing(true);\n            if (result.actionType === 'equip' && result.actionPayload?.items) {\n                const items = result.actionPayload.items;\n                if (items.length === 1) {\n                    await handleSingleEquip(items[0].itemIdentifier, items[0].isHash);\n                } else {\n                    await handleBatchEquip(items);\n                }\n            } else if (result.actionType === 'loadout' && result.actionPayload?.items) {\n                const resultPayload = result.actionPayload;\n                await handleLoadoutAction(resultPayload.items, resultPayload);\n            }\n            setIsProcessing(false);\n        }\n    };\n\n    return (\n        <div className=\"agent-wake-page\">\n            <p className=\"agent-wake-greeting\">What would you like to do today guardian?</p>\n            {response && <p className=\"agent-wake-response\">{response}</p>}\n            <form className=\"agent-wake-input\" onSubmit={handleSubmit}>\n                <div className=\"agent-input-wrapper\">\n                    <input\n                        id=\"agent-command-input\"\n                        name=\"agent-command-input\"\n                        type=\"text\"\n                        value={input}\n                        onChange={e => setInput(e.target.value)}\n                        placeholder=\"Enter a command... (e.g., 'equip sunshot')\"\n                        disabled={isProcessing}\n                        autoComplete=\"off\"\n                        autoFocus\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"agent-search-icon-btn\"\n                        disabled={isProcessing || !input.trim()}\n                        title=\"Execute Command\"\n                    >\n                        <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n                            <circle cx=\"11\" cy=\"11\" r=\"8\" />\n                            <line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\" />\n                        </svg>\n                    </button>\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default AgentWakePage;"],"names":["SUBCLASS_NAMES","generateAbilityKeywords","keywords","formatName","key","elements","classes","element","elementData","SUBCLASS_HASHES","guardianClass","classData","aspectKey","name","grenadeKey","withGrenade","meleeKey","fragmentKey","ABILITY_KEYWORDS","elementMap","identifySubclassByHash","hash","resolveAbilityHash","abilityName","subclassName","abilityType","classKey","constantName","resolveAspectHash","aspectName","isPrismatic","prismaticData","standardHash","PRISMATIC_ASPECT_MAPPING","elem","elemData","resolveFragmentHash","fragmentName","parseSubclassConfig","text","currentSubclassHash","lower","config","currentSubclassName","hashes","subclassPattern","subclassMatch","classSpecificNames","k","elementKeywords","grenadePattern","grenadeMatch","grenadeName","ability","info","keyword","abilityLower","prefix","resolutionContextName","grenadeHash","meleeHash","classAbilityHash","superHash","jumpHash","containsSubclassKeywords","abilityIndicators","indicator","subclassParserService","NAVIGATION_COMMANDS","NAVIGATION_TRIGGERS","EQUIP_TRIGGERS","NATURAL_EQUIP_PATTERNS","normalizeInput","input","isDIMLink","parseEquipCommand","normalized","original","lowerOriginal","trigger","triggerNormalized","afterTrigger","s","itemStr","isHash","parts","afterIndex","itemsString","parseNavigationCommand","cmd","keywordNormalized","fullCommand","suffixes","suffix","parseCommand","trimmed","pattern","match","hasSubclass","items","itemCount","equipCommand","navCommand","AgentWakePage","navigate","useNavigate","setInput","useState","response","setResponse","isProcessing","setIsProcessing","selectedCharacterId","useProfileStore","isAuthenticated","useAuthStore","state","character","c","handleSingleEquip","itemIdentifier","profileLoader","searchResult","itemHash","itemSearchService","definition","item","isExotic","template","ElementType","ItemSlot","i","BUCKET_HASHES","subclassConfig","targetElement","a","f","actionText","result","transferService","error","handleBatchEquip","searchResults","itemNames","r","weapons","armor","exoticWeapon","exoticArmor","legendaryItems","detectElement","results","exoticW","dt","buildTemplate","handleLoadoutAction","resultPayload","newState","configRaw","responseText","compatibleWithPrismatic","aspect","skipSwap","handleSubmit","e","jsxs","jsx"],"mappings":"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"}