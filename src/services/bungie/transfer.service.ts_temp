async equipBuild(
    template: BuildTemplate,
    characterId: string,
    onProgress?: (step: string, progress: number) => void,
    transferOnly = false
  ): Promise<{
    success: boolean;
    equipped: string[];
    failed: string[];
    missing: string[];
    session: MoveSession;
    error?: string;
  }> {
    // Create a MoveSession to track this build equip operation
    const session = createMoveSession([], 5, characterId);
    if (!onProgress) onProgress = (s, p) => debugLog('TransferService', `${s} (${p}%)`);

    onProgress('Syncing inventory...', 2);
    await profileLoader.loadProfile(true);

    const equipped: string[] = [];
    const failed: string[] = [];
    const missing: string[] = [];

    const state = useProfileStore.getState();
    const allInventory: DestinyItem[] = [
      ...state.vaultInventory,
      ...Object.values(state.characterInventories).flat(),
      ...Object.values(state.characterEquipment).flat()
    ];

    // --- PHASE 1: RESOLUTION ---
    onProgress('Analyzing build...', 5);
    const rawArgs = template as any;
    const exoticWeaponDef = template.exoticWeapon || (rawArgs.weapon ? { name: rawArgs.weapon, hash: 0, slot: 1 } : undefined);
    const exoticArmorDef = template.exoticArmor || (rawArgs.armor ? { name: rawArgs.armor, hash: 0, slot: 0 } : undefined);

    const exoticWeapon = (exoticWeaponDef && ((exoticWeaponDef.hash || 0) > 0 || exoticWeaponDef.name))
      ? this.findItemByHashOrName(exoticWeaponDef.hash || 0, exoticWeaponDef.name, allInventory)
      : undefined;

    const exoticArmor = (exoticArmorDef && ((exoticArmorDef.hash || 0) > 0 || exoticArmorDef.name))
      ? this.findItemByHashOrName(exoticArmorDef.hash || 0, exoticArmorDef.name, allInventory)
      : undefined;

    const targetCharItems = [...(state.characterInventories[characterId] || []), ...(state.characterEquipment[characterId] || [])];
    const subclass = this.findSubclassItem(template.element, targetCharItems);

    if (template.exoticWeapon && ((template.exoticWeapon.hash || 0) > 0 || template.exoticWeapon.name) && !exoticWeapon) missing.push(template.exoticWeapon.name || 'Exotic Weapon');
    if (template.exoticArmor && ((template.exoticArmor.hash || 0) > 0 || template.exoticArmor.name) && !exoticArmor) missing.push(template.exoticArmor.name || 'Exotic Armor');
    if (!subclass) missing.push(`${template.element} Subclass`);

    const itemsToTransfer: DestinyItem[] = [];
    if (exoticWeapon) itemsToTransfer.push(exoticWeapon);
    if (exoticArmor) itemsToTransfer.push(exoticArmor);

    if (template.items) {
      for (const tItem of template.items) {
        if (tItem.hash === template.exoticWeapon?.hash || tItem.hash === template.exoticArmor?.hash) continue;
        const item = this.findItemByHashOrName(tItem.hash, tItem.name || 'Unknown', allInventory);
        if (item) itemsToTransfer.push(item);
        else missing.push(tItem.name || `Item ${tItem.hash}`);
      }
    }

    if (missing.length > 0) return { success: false, equipped, failed, missing, session };
    itemsToTransfer.forEach(i => session.involvedItems.add(i.itemInstanceId!));

    // --- PHASE 2: DIM DEQUIP (The "Clear Space" Phase) ---
    // Strictly align with DIM standard: Identify and resolve exotic/slot conflicts BEFORE moving anything.
    onProgress('Clearing conflicting equipment...', 15);
    const conflictReplacements = await this.resolveExoticConflicts(
      characterId,
      exoticWeapon,
      exoticArmor,
      session.excludedItems
    );
    const replacementIds = new Set(conflictReplacements.map(r => r.itemInstanceId));

    // DIM STANDARD: Wait for Bungie's DB to settle after dequips before starting transfers
    if (conflictReplacements.length > 0) {
      await new Promise(r => setTimeout(r, 1000));
      await profileLoader.loadProfile(true);
    }

    // --- PHASE 3: TRANSFER (The "Move" Phase) ---
    onProgress('Moving items to character...', 30);
    for (const item of itemsToTransfer) {
      const currentLoc = this.getItemSource(item);
      if (currentLoc === characterId) continue;
      await this.moveItem(item, currentLoc, characterId, session, { silent: true });
    }

    if (transferOnly) {
      onProgress('Items transferred successfully!', 100);
      return { success: true, equipped: [], failed: [], missing: [], session };
    }

    // --- PHASE 4: EQUIP (The "Equip" Phase) ---
    onProgress('Equipping items...', 50);
    
    // Equip subclass first if changing
    if (subclass && template.subclassConfig?.subclassHash) {
      const currentSubclass = (state.characterEquipment[characterId] || []).find(i => i.bucketHash === BUCKET_HASHES.SUBCLASS);
      if (currentSubclass?.itemInstanceId !== subclass.itemInstanceId) {
        await this.equipItem(subclass.itemInstanceId!, characterId, { silent: true });
        await new Promise(r => setTimeout(r, 1000)); // DIM gap
      }
    }

    const loadoutIds: string[] = [
      ...conflictReplacements.map(i => i.itemInstanceId!),
      ...(exoticWeapon ? [exoticWeapon.itemInstanceId!] : []),
      ...(exoticArmor ? [exoticArmor.itemInstanceId!] : []),
      ...itemsToTransfer.filter(i => 
        i.itemInstanceId !== exoticWeapon?.itemInstanceId && 
        i.itemInstanceId !== exoticArmor?.itemInstanceId && 
        !replacementIds.has(i.itemInstanceId)
      ).map(i => i.itemInstanceId!)
    ];

    const uniqueLoadoutIds = Array.from(new Set(loadoutIds));
    const equipResult = await this.equipItems(uniqueLoadoutIds, characterId, 0, { silent: true });

    // --- PHASE 5: DIM SETTLE & SOCKETS ---
    // Strictly align with DIM standard: Wait for equip to settle before socketing.
    onProgress('Configuring perks and mods...', 70);
    await new Promise(r => setTimeout(r, 2000));
    await profileLoader.loadProfile(true);

    const socketTasks: Array<() => Promise<void>> = [];
    const queueSocketOverrides = (item: DestinyItem | undefined, overrides: Record<number, number> | undefined) => {
      if (!item?.itemInstanceId || !overrides) return;
      socketTasks.push(() => this.applyItemSocketOverrides(item.itemInstanceId!, overrides, characterId));
    };

    queueSocketOverrides(exoticWeapon, template.exoticWeapon?.socketOverrides);
    queueSocketOverrides(exoticArmor, template.exoticArmor?.socketOverrides);
    template.items?.forEach(tItem => {
      const item = itemsToTransfer.find(i => i.itemHash === tItem.hash);
      if (item && tItem.socketOverrides) queueSocketOverrides(item, tItem.socketOverrides);
    });

    for (const task of socketTasks) await task();

    let orbitRequired = false;
    if (subclass && template.subclassConfig) {
      try {
        await this.applySubclassConfiguration(subclass, template.subclassConfig, characterId, onProgress);
      } catch (error: any) {
        if (error.message === 'ORBIT_REQUIRED') orbitRequired = true;
        else throw error;
      }
    }

    // --- PHASE 6: MODS ---
    onProgress('Applying armor mods...', 90);
    if (template.armorMods && template.armorMods.length > 0) {
      await this.applyArmorMods(characterId, template.armorMods, onProgress);
    }

    onProgress('Build equipped successfully!', 100);
    return {
      success: equipResult.success,
      equipped: uniqueLoadoutIds,
      failed: equipResult.failedIds,
      missing: [],
      session,
      error: orbitRequired ? 'Go to Orbit or Tower to apply subclass changes.' : undefined
    };
  }